---
title: 'Creating an AI-Powered Search Input With Phoenix LiveView'
date: '2025-02-23'
tags: ['elixir', 'phoenix', 'liveview', 'openai', 'ai-filters']
draft: false
summary: 'Learn how to integrate OpenAI with Phoenix LiveView to build an intelligent search bar that dynamically translates user queries into structured filters.'
authors: ['default']
---

When we think about AI-powered applications, we often imagine complex machine-learning models, autonomous systems, or advanced recommendation engines. However, AI doesn‚Äôt have to be limited to large-scale, highly complex solutions‚Äîit can also be used to enhance everyday user experiences in **simple yet impactful ways**.

One of the most frustrating experiences in modern web applications is **searching for data efficiently**. Whether users are searching through **projects, tasks, orders, or customer records**, they often have to navigate through tedious and rigid filtering options.

## **Think about how typical search filters work in most applications today**

- Users are presented with a **series of dropdowns, checkboxes, or date pickers**.
- They need to **manually select multiple filters**, such as status, date range, or category.
- If they **don‚Äôt configure the filters correctly**, they might get **zero results** or **irrelevant results**.
- Searching in **multiple languages**? That‚Äôs usually **not supported** without explicitly choosing a language filter.

All of this adds **cognitive load** to the user and makes the search more **frustrating** than it needs to be.

## **What If We Made Search Smarter?**

What if, instead of requiring users to **manually configure filters**, they could just **describe what they‚Äôre looking for using plain language**?

Imagine a search bar that allows users to type queries like:

- _"Show me active internal projects."_
- _"Find all projects with a target date in March."_
- _"List small or medium projects that are archived."_
- _"Muestra los proyectos internos activos."_ (Spanish)
- _"Afficher tous les projets archiv√©s."_ (French)

Instead of **forcing the user** to understand the structure of the database, **manually select filters**, or **use specific keywords**, our system will **interpret their intent** and convert it into structured filters automatically‚Äî**regardless of the language they use**.

This is exactly what we‚Äôll build in this article:

‚úÖ A **smart search input in Phoenix LiveView** that allows users to search **naturally**.  
‚úÖ An **integration with OpenAI‚Äôs GPT API** to **translate user queries into structured filters**.  
‚úÖ A **dynamic system** that works seamlessly in **multiple languages** without extra configuration.

## **How We‚Äôll Build This**

To achieve this, we‚Äôll leverage:

- **[Phoenix LiveView](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html)** ‚Äì to create a **real-time search interface** with instant feedback.
- **[Ecto](https://hexdocs.pm/ecto/Ecto.html)** ‚Äì to dynamically **apply AI-generated filters** to our database queries.
- **[OpenAI API](https://platform.openai.com/docs/)** ‚Äì to convert **natural language queries** into structured **JSON filters** that our backend can understand.

By the end of this guide, you‚Äôll have a **fully functional AI-powered search bar** that eliminates the complexity of manual filtering and allows users to search in a way that **feels natural**.

üìå **Important Note:** The following **code snippets** are **examples** meant to explain how this system works. If you want the **full working implementation**, you can find it in the **GitHub repository** at the end of the article.

## **Why This Approach Matters**

üîπ **Improves User Experience** ‚Äì No more **confusing filter interfaces**. Users just **type what they need**.  
üîπ **Supports Multiple Languages** ‚Äì Works with **English, Spanish, French**, and many more **without extra effort**.  
üîπ **AI-Driven, But Simple** ‚Äì We‚Äôre **not building a chatbot** or a **complex AI assistant**. We‚Äôre just using **AI to enhance a common UI component‚Äîsearch**.  
üîπ **Real-Time and Efficient** ‚Äì Thanks to **Phoenix LiveView**, the search will be **instant**, giving users an **interactive experience without page reloads**.

## **Building the AI-Powered Filter Generation Service**

At the core of our intelligent search system is a service module that interacts with OpenAI‚Äôs API. This service translates natural language queries into structured filters, which can then be used in our database queries.

### **What This Service Does**

‚úÖ Accepts user queries as free-text input.  
‚úÖ Sends them to OpenAI‚Äôs GPT-4 model with a detailed prompt explaining how the response should be structured.  
‚úÖ Extracts the AI-generated JSON filters and makes them usable in our Ecto queries.

### **Defining the OpenAI Request Service**

Here‚Äôs the implementation of our Elixir service module that makes a request to OpenAI and processes the response:

```elixir
defmodule PhoenixLiveViewAiFiltersPoc.Projects.Services.BuildProjectFilters do
  @moduledoc """
  Converts natural language queries into structured filters for project search.
  """

  @model "gpt-4-turbo"
  @role_content """
  Generate a JSON object with project filters based on the user's query.

  ## Filtering Options:
  - `code`: Project code.
  - `name`: Project name.
  - `status`: Project status (`active`, `done`, `archived`, `deleted`, `draft`).
  - `type`: Project type (`internal`, `external`).
  - `target_date`: Project target date (use today's date as a reference: #{Date.utc_today()}).

  ## Instructions:
  - Return **only a valid JSON object**‚Äîno extra text, comments, or markdown.
  - If dates are referenced, use a range if appropriate.
  - Ensure correct enum values for status and type.
  - The system supports multiple languages, so interpret queries accordingly.
  """

  @spec call(String.t()) :: map()
  def call(query) do
    OpenAI.chat_completion(
      model: @model,
      messages: [
        %{role: "system", content: @role_content},
        %{role: "user", content: query}
      ]
    )
    |> case do
      {:ok, %{choices: choices}} ->
        {:ok, Jason.decode!(List.first(choices)["message"]["content"], keys: :atoms!)}
      {:error, _reason} ->
        {:error, %{}}
    end
  end
end
```

#### **Breaking Down the AI Filter Service**

##### **1Ô∏è‚É£ Setting Up the AI Model**

```elixir
  @model "gpt-4-turbo"
```

- Specifies `gpt-4-turbo` as the AI model for processing queries.
- You can experiment with different OpenAI models (`gpt-4`, `gpt-3.5-turbo`) based on performance needs.

üîó **[OpenAI GPT Models Documentation](https://platform.openai.com/docs/models/gpt-4)**

##### **2Ô∏è‚É£ Defining the System Prompt for AI**

```elixir
  @role_content """
  Generate a JSON object with project filters based on the user's query.

  ## Filtering Options:
  - `code`: Project code.
  - `name`: Project name.
  - `status`: Project status (`active`, `done`, `archived`, `deleted`, `draft`).
  - `type`: Project type (`internal`, `external`).
  - `target_date`: Project target date (use today's date as a reference: #{Date.utc_today()}).

  ## Instructions:
  - Return **only a valid JSON object**‚Äîno extra text, comments, or markdown.
  - If dates are referenced, use a range if appropriate.
  - Ensure correct enum values for status and type.
  - The system supports multiple languages, so interpret queries accordingly.
  """
```

- Clearly defines **expected output** (a JSON object containing filters).
- Restricts AI response to **JSON only** (no extra text or comments).
- Ensures AI understands multi-language input.
- Uses `Date.utc_today()` to dynamically adjust references to the current date.

##### **3Ô∏è‚É£ Making the API Call to OpenAI**

```elixir
  @spec call(String.t()) :: map()
  def call(query) do
    OpenAI.chat_completion(
      model: @model,
      messages: [
        %{role: "system", content: @role_content},
        %{role: "user", content: query}
      ]
    )
```

- `call/1` accepts a user query and sends it to OpenAI.
- Provides **system instructions** (`@role_content`) and user input (`query`).
- Uses **chat_completion** for structured output.

üîó **[OpenAI API - Chat Completions](https://platform.openai.com/docs/guides/gpt)**

##### **4Ô∏è‚É£ Processing the AI Response**

```elixir
    |> case do
      {:ok, %{choices: choices}} ->
        {:ok, Jason.decode!(List.first(choices)["message"]["content"], keys: :atoms!)}
      {:error, _reason} ->
        {:error, %{}}
    end
```

- If the API call succeeds, it decodes the **first response choice** into a structured Elixir map.
- Uses `Jason.decode!/2` to **convert JSON to Elixir atoms**.
- If the API request fails, it **returns an empty map instead of breaking the app**.

### **Why This Approach Works Well**

‚úÖ **Scalable** ‚Äì Works with any number of filters, just update `@role_content`.  
‚úÖ **Multi-language Support** ‚Äì AI automatically detects and interprets queries in English, Spanish, French, and more.  
‚úÖ **Future-proof** ‚Äì Can be extended with new filters (e.g., categories, tags).  
‚úÖ **Fails Safely** ‚Äì If OpenAI fails, we don‚Äôt break the app‚Äîjust return an empty filter set.

This module is responsible for transforming a user‚Äôs natural language search query into structured filters. The next section will break down how we integrate this with **Phoenix LiveView** and dynamically update search results in real-time.

## **Breaking Down the LiveView Integration**

This **LiveView module** is responsible for managing the **search bar UI**, interacting with **OpenAI‚Äôs AI-powered filter service**, and updating the **project list dynamically**.

Let‚Äôs go through the code step by step:

### **1Ô∏è‚É£ Setting Up the LiveView Component**

```elixir
defmodule PhoenixLiveViewAiFiltersPocWeb.ProjectLive.Index do
  use PhoenixLiveViewAiFiltersPocWeb, :live_view
```

This defines a **LiveView module** that will handle **real-time user interactions**.

- **LiveView** enables **dynamic updates** without requiring a full-page reload.

üîó **[Phoenix LiveView Documentation](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html)**

### **2Ô∏è‚É£ Importing Dependencies**

```elixir
alias PhoenixLiveViewAiFiltersPoc.Projects
alias PhoenixLiveViewAiFiltersPoc.Projects.Services.BuildProjectFilters
```

- `Projects` ‚Üí Handles **fetching project data** from the database.
- `BuildProjectFilters` ‚Üí Calls **OpenAI to convert user queries into structured filters**.

### **3Ô∏è‚É£ Initializing the LiveView State (`mount/3`)**

```elixir
@impl true
def mount(_params, _session, socket) do
  {:ok, assign(socket, filters: %{}, query: "", projects: fetch_projects(%{}))}
end
```

#### **What is happening here?**

- `mount/3` is called when the LiveView **is first rendered**.
- Initializes the **component‚Äôs state** by assigning:
  - `filters: %{}` ‚Üí No filters applied initially.
  - `query: ""` ‚Üí Empty search input.
  - `projects: fetch_projects(%{})` ‚Üí Loads **all projects initially**.

üëâ **Why is this important?**

- The page **loads with all projects displayed**.
- Filters are **empty until the user enters a query**.

üîó **[More about `mount/3` in LiveView](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#c:mount/3)**

### **4Ô∏è‚É£ Handling the User's Search Query (`handle_event/3`)**

```elixir
@impl true
def handle_event("trigger-search", %{"search" => %{"query" => query}}, socket) do
  filters = case BuildProjectFilters.call(query) do
    {:ok, filters} -> filters
    _ -> %{}
  end
  {:noreply, assign(socket, :filters, filters, :projects, fetch_projects(filters))}
end
```

#### **What does this function do?**

- **Listens** for a `"trigger-search"` event, triggered when the user **submits the search form**.
- Extracts the **query** from the search input.
- Calls `BuildProjectFilters.call(query)`, which **converts the query into AI-generated filters**.
- Updates the **LiveView state** (`filters` and `projects`) based on the **AI response**.

#### **Error Handling**

- If OpenAI **fails** or **returns an empty response**, we fall back to an **empty filter set (`%{}`)** to **ensure the app doesn‚Äôt break**.

üëâ **Why use `assign(socket, ...)`?**

- **LiveView‚Äôs `assign/3` function** updates state **efficiently**, ensuring that only the necessary **parts of the UI re-render**, making updates **fast**.

üîó **[More about `handle_event/3` in LiveView](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#c:handle_event/3)**

### **5Ô∏è‚É£ Fetching Filtered Projects from the Database (`fetch_projects/1`)**

```elixir
defp fetch_projects(filters) do
  Projects.list_projects(filters)
end
```

#### **What does this function do?**

- Retrieves **projects** from the database based on the **applied filters**.
- Calls `Projects.list_projects(filters)`, which will later be **modified to handle AI-generated filters**.

üëâ **Why is this in a separate function?**

- Keeping it **separate makes it reusable**.
- We can **reuse `fetch_projects/1`** in other parts of the app, if needed.

### **Why This Approach Works Well**

‚úÖ **Real-Time Search Updates** ‚Äì **LiveView updates dynamically** without reloading the page.  
‚úÖ **AI-Powered Queries** ‚Äì Users **don‚Äôt need to learn filter structures**‚Äîthey just type **naturally**.  
‚úÖ **Multi-Language Support** ‚Äì Works with **English, Spanish, French**, and more!  
‚úÖ **Resilient Design** ‚Äì If OpenAI fails, the app still **functions without breaking**.

This completes the **LiveView integration** for **AI-powered search**! üöÄ In the next section, we will explore **how to dynamically filter projects using Ecto queries**.

üîú **Next: Applying AI-Generated Filters to Ecto Queries**

## **Filtering Projects with Ecto**

Now that we have AI-generated filters from OpenAI, we need to apply them dynamically to an **Ecto query** to retrieve matching records from the database.

### **What We Need to Do:**

‚úÖ Convert AI-generated filters into **Ecto query conditions**.  
‚úÖ Dynamically apply these conditions based on what the **user searched for**.  
‚úÖ Return **only the relevant projects** that match the search criteria.

To achieve this, we create a **dynamic Ecto query module** that processes the filters and returns a **filtered list of projects**.

### **Building the Dynamic Ecto Query**

Here‚Äôs the **Ecto-based implementation** that applies AI-generated filters dynamically:

```elixir
defmodule PhoenixLiveViewAiFiltersPoc.Projects.Finders.ListProjects do
  import Ecto.Query
  alias PhoenixLiveViewAiFiltersPoc.Projects.Project
  alias PhoenixLiveViewAiFiltersPoc.Repo

  def find(filters \ %{}) do
    from(project in Project)
    |> apply_filters(filters)
    |> Repo.all()
  end

  defp apply_filters(query, filters), do: Enum.reduce(filters, query, &apply_filter/2)

  defp apply_filter({:status, value}, query), do: where(query, [p], p.status == ^value)
  defp apply_filter({:type, value}, query), do: where(query, [p], p.type == ^value)
  defp apply_filter({:target_date, [start_date, end_date]}, query),
    do: where(query, [p], p.target_date >= ^start_date and p.target_date <= ^end_date)
end
```

### **Breaking Down the Ecto Query**

This module **takes AI-generated filters** and applies them dynamically to an **Ecto query**. Let‚Äôs analyze the code step by step.

#### **1Ô∏è‚É£ Defining the Module and Imports**

```elixir
defmodule PhoenixLiveViewAiFiltersPoc.Projects.Finders.ListProjects do
  import Ecto.Query
  alias PhoenixLiveViewAiFiltersPoc.Projects.Project
  alias PhoenixLiveViewAiFiltersPoc.Repo
```

üîπ **Why use `import Ecto.Query`?**
This allows us to use **`from/2`**, **`where/3`**, and other **Ecto Query API functions** directly.

üîó [Ecto Query Documentation](https://hexdocs.pm/ecto/Ecto.Query.html)

üîπ **Why use `alias PhoenixLiveViewAiFiltersPoc.Projects.Project`?**
This lets us reference `Project` **directly** instead of writing `PhoenixLiveViewAiFiltersPoc.Projects.Project` every time.

üîπ **Why use `alias PhoenixLiveViewAiFiltersPoc.Repo`?**
It allows us to call `Repo.all(query)` **without needing to specify the full module path**.

#### **2Ô∏è‚É£ The `find/1` Function - Entry Point**

```elixir
def find(filters \ %{}) do
  from(project in Project)
  |> apply_filters(filters)
  |> Repo.all()
end
```

üîπ **What does this function do?**

- **`filters \ %{}`** ‚Üí If no filters are provided, it defaults to an **empty map** (returns all projects).
- **`from(project in Project)`** ‚Üí This is an **Ecto query struct** that represents an **SQL query**.
- **`apply_filters(filters)`** ‚Üí **Dynamically applies filters** to the query.
- **`Repo.all(query)`** ‚Üí Executes the final **SQL query** and returns the results.

üëâ **Why use `from(project in Project)` instead of `Project` directly?**

Using **`from/2`** allows us to modify the query **dynamically before executing it**.

üîó [More about `from/2` in Ecto Queries](https://hexdocs.pm/ecto/Ecto.Query.html#from/2)

#### **3Ô∏è‚É£ Applying Filters Dynamically (`apply_filters/2`)**

```elixir
defp apply_filters(query, filters), do: Enum.reduce(filters, query, &apply_filter/2)
```

üîπ **What does this do?**

- **`filters`** is a **map** of AI-generated **filter conditions**.
- **`Enum.reduce/3`** iterates through each **filter** and modifies the query **accordingly**.
- It calls **`apply_filter/2`** for each filter, adding a **WHERE condition dynamically**.

üëâ **Why use `Enum.reduce/3`?**

This allows us to **build queries dynamically**, adding conditions **only when filters exist**.
Without this, we‚Äôd have to **hardcode conditions**, making the query **less flexible**.

#### **4Ô∏è‚É£ Handling Individual Filters (`apply_filter/2`)**

Now let‚Äôs break down how we apply **each filter condition dynamically**.

##### **Filtering by Status**

```elixir
defp apply_filter({:status, value}, query), do: where(query, [p], p.status == ^value)
```

‚úÖ **Checks if the filters map contains a `:status` key**.  
‚úÖ **Adds `WHERE status = 'some_value'` to the query**.

üîó [More about `where/3` in Ecto](https://hexdocs.pm/ecto/Ecto.Query.html#where/3)

##### **Filtering by Type**

```elixir
defp apply_filter({:type, value}, query), do: where(query, [p], p.type == ^value)
```

‚úÖ **Works the same way as `status`**, but filters by **project type** (e.g., `internal` vs. `external`).

##### **Filtering by Date Range**

```elixir
defp apply_filter({:target_date, [start_date, end_date]}, query),
  do: where(query, [p], p.target_date >= ^start_date and p.target_date <= ^end_date)
```

‚úÖ **Handles date range filtering** (e.g., `"Show projects from March to May"`).  
‚úÖ **Ensures that the project‚Äôs `target_date` falls within the specified range**.

üëâ **Why use `[start_date, end_date]` instead of a single value?**

- This allows AI-generated filters to specify both an **exact date** and a **range**.
- If AI detects a **specific month**, it can return the **full month range** instead of a **single date**.

### **Why This Approach Works Well**

‚úÖ **Dynamic Query Construction** ‚Äì No need for **hardcoded conditions**; filters apply **dynamically**.  
‚úÖ **AI-Driven Search Logic** ‚Äì Users don‚Äôt need to manually pick filters, **AI does it for them**.  
‚úÖ **Optimized SQL Queries** ‚Äì Uses **Ecto‚Äôs `where/3`** for **efficient filtering**.  
‚úÖ **Supports Date Ranges** ‚Äì Users can search by **month, year, or exact date**.

This module ensures that **AI-generated filters** are **efficiently applied** to our **database queries**, giving users a **seamless and intelligent search experience**.

With our **Ecto-powered filtering system** in place, we can now move on to dynamically **displaying the filtered results in Phoenix LiveView**. üöÄ

## **Displaying Results in LiveView**

Now that we have successfully applied AI-generated filters to Ecto queries, we need to display the filtered results dynamically in **Phoenix LiveView**.

### **What We Need to Do**

‚úÖ Update the **LiveView template** to show **filtered project results**.  
‚úÖ Display **applied filters** in the UI so users can **see what‚Äôs being used**.  
‚úÖ Ensure the **search bar updates results in real-time**.

### **Updating the LiveView Template**

We modify our **LiveView template** to:

- Provide a **search input** for users to type queries.
- Show **active filters applied** by AI.
- Display the **filtered list of projects** dynamically.

Here‚Äôs the updated `index.html.heex` file:

```html
<.header>
  Listing Projects
  <:actions>
    <.link patch={~p"/projects/new"}>
      <.button>New Project</.button>
    </.link>
  </:actions>
</.header>

<div class="flex gap-2 items-center pt-4 text-sm">
  <.form :let={f} for={%{}} as={:search} phx-submit="trigger-search" class="flex gap-2">
    <.input
      class="mt-2"
      field={f[:query]}
      value={@query}
      placeholder="Search for projects..."
      size="48"
    />
    <.button class="mt-2"><.icon name="hero-sparkles" class="w-4 h-4" /></.button>
  </.form>

  <%= if !is_nil(@filters) do %>
    <.button phx-click="reset-search" class="mt-2">
      <.icon name="hero-arrow-path" class="w-4 h-4" />
    </.button>
  <% end %>
</div>

<%= if !is_nil(@filters) do %>
  <div class="flex gap-2 items-center pt-4 text-sm">
    <%= for {filter, value} <- @filters do %>
      <span class="bg-blue-100 text-blue-800 text-xs font-medium me-2 px-2.5 py-0.5 rounded dark:bg-blue-900 dark:text-blue-300">
        <b><%= filter %></b>: <%= value %>
      </span>
    <% end %>
  </div>
<% end %>

<.table
  id="projects"
  rows={@streams.projects}
  row_click={fn {_id, project} -> JS.navigate(~p"/projects/#{project}") end}
>
  <:col :let={{_id, project}} label="Name"><%= project.name %></:col>
  <:col :let={{_id, project}} label="Code"><%= project.code %></:col>
  <:col :let={{_id, project}} label="Status"><%= project.status %></:col>
  <:col :let={{_id, project}} label="Type"><%= project.type %></:col>
  <:col :let={{_id, project}} label="Estimation"><%= project.estimation %></:col>
  <:col :let={{_id, project}} label="Target date"><%= project.target_date %></:col>
  <:action :let={{_id, project}}>
    <div class="sr-only">
      <.link navigate={~p"/projects/#{project}"}>Show</.link>
    </div>
    <.link patch={~p"/projects/#{project}/edit"}>Edit</.link>
  </:action>
  <:action :let={{id, project}}>
    <.link
      phx-click={JS.push("delete", value: %{id: project.id}) |> hide("##{id}")}
      data-confirm="Are you sure?"
    >
      Delete
    </.link>
  </:action>
</.table>
```

### **Breaking Down the LiveView Template**

#### **1Ô∏è‚É£ Search Bar (User Input)**

```html
<.form :let={f} for={%{}} as={:search} phx-submit="trigger-search" class="flex gap-2">
  <.input
    class="mt-2"
    field={f[:query]}
    value={@query}
    placeholder="Search for projects..."
    size="48"
  />
  <.button class="mt-2"><.icon name="hero-sparkles" class="w-4 h-4" /></.button>
</.form>
```

‚úÖ **Creates a search form** using `phx-submit="trigger-search"`, which triggers the **LiveView event** when the form is submitted.  
‚úÖ The **input field** (`@query`) holds the **user's search text**.  
‚úÖ Pressing the search button **submits the query**, passing it to OpenAI to generate filters.

üîó [More about handling form inputs in LiveView](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#phx-submit)

#### **2Ô∏è‚É£ Displaying Active Filters**

```html
<%= if !is_nil(@filters) do %>
<div class="flex gap-2 items-center pt-4 text-sm">
  <%= for {filter, value} <- @filters do %>
  <span
    class="bg-blue-100 text-blue-800 text-xs font-medium me-2 px-2.5 py-0.5 rounded dark:bg-blue-900 dark:text-blue-300"
  >
    <b><%= filter %></b>: <%= value %>
  </span>
  <% end %>
</div>
<% end %>
```

‚úÖ **Dynamically displays the filters** generated by **OpenAI**.  
‚úÖ Each filter is shown as a **badge**, making it **clear what is currently being used**.  
‚úÖ Users can **reset filters** using the reset button.

#### **3Ô∏è‚É£ Displaying Filtered Project Results**

```html
<.table
  id="projects"
  rows={@streams.projects}
  row_click={fn {_id, project} -> JS.navigate(~p"/projects/#{project}") end}
>
  <:col :let={{_id, project}} label="Name"><%= project.name %></:col>
  <:col :let={{_id, project}} label="Code"><%= project.code %></:col>
  <:col :let={{_id, project}} label="Status"><%= project.status %></:col>
  <:col :let={{_id, project}} label="Type"><%= project.type %></:col>
  <:col :let={{_id, project}} label="Estimation"><%= project.estimation %></:col>
  <:col :let={{_id, project}} label="Target date"><%= project.target_date %></:col>
```

‚úÖ Uses **LiveView‚Äôs** `@streams` to dynamically update the **table**.  
‚úÖ Clicking a **project** redirects to its **details page** via `JS.navigate/1`.  
‚úÖ **Data is updated in real-time** as **AI-generated filters** are applied.

### **Why This Works Well**

‚úÖ **Instant UI Updates** ‚Äì Users see results **immediately after searching**.  
‚úÖ **Clear Filter Visibility** ‚Äì Shows **exactly which filters AI has applied**.  
‚úÖ **Scalable & Maintainable** ‚Äì Works seamlessly with **any number of filters**.  
‚úÖ **Interactive & User-Friendly** ‚Äì **LiveView** handles everything **dynamically**.

This ensures an **enhanced search experience** by seamlessly integrating **AI-generated filters** into a **dynamic, real-time UI**. üöÄ

## **Final Thoughts**

We've successfully built a **real-time, AI-powered search experience** using:

‚úÖ **Phoenix LiveView** for instant UI updates.  
‚úÖ **OpenAI** for intelligent, natural-language-driven filtering.  
‚úÖ **Ecto** for applying AI-generated filters dynamically to our database queries.

### **What Makes This Approach Powerful?**

üí° **Intuitive User Experience** ‚Äì Users no longer need to manually select filters; they just type naturally.  
üí° **Multilingual Search Support** ‚Äì The AI understands and processes queries in any language.  
üí° **Dynamic and Scalable** ‚Äì The filtering system is flexible and can be expanded with more data sources.  
üí° **No Page Reloads** ‚Äì Thanks to **LiveView**, search results update in real time.

By eliminating the **cognitive load** of traditional filtering interfaces, we've created a **smart, user-friendly, and efficient** way for users to find what they need faster.

## **üöÄ Next Steps: Taking It Further**

### **1Ô∏è‚É£ Implement Caching for Performance Optimization**

**OpenAI API calls** add network latency and can be costly over time. Consider caching AI-generated filters using:

- **ETS (Erlang Term Storage)** ‚Äì [ETS Docs](https://www.erlang.org/doc/man/ets.html)
- **Redis** ‚Äì [Redis Caching Docs](https://redis.io/docs/manual/keyspace/)

üëâ **How This Helps:**

‚úÖ Reduces redundant OpenAI requests for the same query.  
‚úÖ Speeds up search results for repeated queries.

### **2Ô∏è‚É£ Improve AI Query Understanding**

- Fine-tune the **AI prompt** to handle edge cases better.
- Provide the AI with **example queries** and expected outputs.
- Validate **AI-generated filters** before applying them.

üëâ **How This Helps:**

‚úÖ Ensures **higher accuracy** when converting user queries into filters.  
‚úÖ Prevents **misinterpretation** of ambiguous search terms.

### **3Ô∏è‚É£ Support Additional Data Sources**

Right now, we **filter projects** based on user queries. What if we extended this to more datasets, such as:

‚úÖ **Users & Team Members** ‚Äì _"Show me all active developers in the team."_  
‚úÖ **Tasks & Tickets** ‚Äì _"Find high-priority tasks assigned to Ivan."_  
‚úÖ **Invoices & Transactions** ‚Äì _"List all invoices from last quarter."_

üëâ **How This Helps:**

‚úÖ Makes the **search bar more versatile** across different business domains.  
‚úÖ Provides **consistent AI-powered filtering** across multiple models.

### **4Ô∏è‚É£ Enhance Search with Semantic Understanding**

Instead of just **matching keywords**, train a **custom AI model** to:

‚úÖ **Understand contextual search queries**.  
‚úÖ **Recognize synonyms and variations** of search terms.  
‚úÖ **Handle comparative queries** (e.g., _"projects bigger than X"_).

üëâ **How This Helps:**

‚úÖ Creates a **smarter and more human-like** search experience.  
‚úÖ Reduces the need for **exact keyword matches**.

## Demo

[Watch the demo video!](https://www.awesomescreenshot.com/video/36903860?key=5dca7faccf4cdef5db3d1c5fdca39908).

## **üìå Full Code and Repository**

Want to explore the **full implementation** of this AI-powered search bar?
Check out the complete working code on **GitHub**:

üîó **GitHub Repository:** [GitHub Repository](https://github.com/dreamingechoes/phoenix_live_view_ai_filters_poc)

## **‚ú® Final Challenge: Try It in Your Project!**

üöÄ Now that you've seen how to build an **AI-powered search bar**, try implementing it in your own **Phoenix LiveView** project!

üîπ **What other use cases can you think of?**  
üîπ **How would you fine-tune the AI‚Äôs responses?**  
üîπ **Could you integrate this with voice input** for an even better experience?
